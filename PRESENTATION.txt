Nebula Chat â€” Presentation Guide

Note about scope
- This outline describes a richer demo with accounts, rooms, uploads, etc.
- The current code is a minimal singleâ€‘room chat used for learning. Treat the extras here as future ideas.

1) What It Is (1â€“2 minutes)
- A real-time web chat built with Node.js, Express and Socket.IO.
- Features: accounts (with simple username+password), admin role, rooms (#general, #announcements), direct messages, typing indicators, file uploads (PNG/JPG/PDF), unread badges, and persistence (messages survive restarts).
  - Profile pictures: users can upload a PNG/JPG avatar; avatars display in user list and messages and persist.
  - Reactions: quick emoji reactions (ğŸ‘ â¤ï¸ ğŸ˜‚ ğŸ˜® ğŸ˜¢) on messages with live counts that persist.
- Runs on a Raspberry Pi; can be shared publicly via ngrok.

2) Demo Flow (4â€“6 minutes)
- Start: `cd chatroom && npm run up` (optionally: `-- --admin-pass "<secret>"`).
- Sign in popup:
  - Guest: leave both fields empty and click Continue.
  - Member: enter a username + password to register the first time; use them again later to log in.
  - Admin: username `admin` with the configured admin password.
- Rooms:
  - Post in #general. Note timestamps, bubble alignment, and â€œwhoâ€ colors.
  - Switch to #announcements â€” only admin can post; others see a hint and disabled composer.
- Direct Messages:
  - Click a username in the left sidebar to open a DM tab (@name). The other user sees a DM tab appear automatically.
  - Send messages (and PNG/PDF attachments) privately; DM typing indicators show while the other is typing.
  - Close the DM tab with â€œÃ—â€; re-open later by clicking the user again.
  - React to messages with emojis; delete or edit your own.
- Unread badges:
  - Switch to another tab and send a message from a different user into the inactive tab; a red badge increments until you focus that chat.
- Persistence:
  - Restart the server; room and DM histories are still present.
- Sign out: click â€œSign outâ€ in the left sidebar.

3) How It Works (5â€“7 minutes)
- Transport: Socket.IO upgrades HTTP to WebSocket; clients subscribe to rooms (e.g., `general`) and private DM channels (e.g., `dm:<a>::<b>`).
- Authentication (demo-simple):
  - Session cookie via express-session. On login, the server sets `req.session.user = {name, role, color}`.
  - Admin credentials are controlled by env vars (`ADMIN_PASSWORD`, username defaults to `admin`).
  - Member passwords are stored in plaintext in `chatroom/data/users.txt` per the assignmentâ€™s request (demo only).
- Rooms and DMs:
  - Rooms: `general` and `announcements`. Only admin can post in `announcements`.
  - DMs: canonical key `dm:<a>::<b>` (lowercased + sorted). Both users join that Socket.IO room.
- Events:
  - Server â†’ Client: `room:joined`, `users:list`, `system`, `message`, `dm:joined`, `dm:opened_by_other`, `dm:message`, `typing:update`, `dm:typing:update`.
  - Client â†’ Server: `room:join`, `message`, `dm:open`, `dm:leave`, `dm:message`, `typing`, `dm:typing`.
- Persistence:
  - JSON Lines (JSONL) files inside `chatroom/data`.
    - Rooms: `data/rooms/room-<name>.jsonl` (one message per line).
    - DMs: `data/dms/dm-<userA>__<userB>.jsonl`.
  - On startup, files are read back into memory; new messages append to the relevant JSONL file.
  - Pros: easy to inspect and append; good for a Pi-scale demo. (Cons: not efficient for very large histories.)
- Uploads:
  - Multer handles PNG/JPG/PDF up to 8MB; stored under `chatroom/uploads/` and linked in messages.
  - Avatars: PNG/JPG up to 4MB; stored under `chatroom/uploads/avatars/` and mapped to usernames in `data/avatars.txt`.
  - Uploads work in rooms and DMs (the API detects `room` vs `peer`).
- UI logic:
  - Tabs for rooms + on-demand DM tabs with close button.
  - Unread badges increment if a message arrives for an inactive tab, the window is unfocused, or youâ€™re scrolled up.
  - Typing indicators show for rooms and DMs.

4) Code Map (2â€“3 minutes)
- Server: `server.js`
  - Express app, sessions, auth routes (`/api/login`, `/api/logout`, `/api/me`), uploads (`/api/upload`).
  - Socket.IO handlers: rooms, DMs, typing, and broadcasting.
  - Persistence helpers: JSONL append/load in `data/rooms` and `data/dms`.
- Client: `public/`
  - `index.html` (layout), `styles.css` (2010-style theme), `app.js` (logic for login, tabs, DMs, typing, unread badges, attachments).
- Scripts: `scripts/up.js` (one-line start), `scripts/down.js` (one-line stop).
- Docs: `RUNBOOK.txt` (how to run), `ARCHITECTURE.txt` (architecture), `PRESENTATION.txt` (this file).

5) Security Notes (1â€“2 minutes)
- Demo-only choices: plaintext passwords, permissive CORS, relaxed Helmet CSP, file uploads without scanning.
- For production: hash passwords (argon2/bcrypt), enforce HTTPS, CSRF tokens, rate limits, file virus scanning, and a real database.

6) Operating It (1 minute)
- Start: `npm run up` (add `-- --admin-pass "<secret>"` to set admin password).
- Stop: `npm run down`.
- Public sharing: start ngrok (`npm run up` already does if configured) and share the HTTPS URL.

7) Future Work (optional)
- Unread persistence across sessions, message search, user profiles, message reactions, moderation tools, and moving to SQLite/Postgres for history.
